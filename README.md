# Лабораторная работа №2  
_Обобщённая работа с последовательностями на шаблонах_

---

## Постановка задачи  

Реализовать иерархию классов для работы с последовательностями с использованием шаблонов.  
Поддержать основные операции (вставка, удаление, доступ по индексу, фильтрация, отображение, свёртка).  
Обеспечить интерфейс пользователя для работы с различными типами данных (например, `int`, `float`).

---

## Описание решения  
### Используемые типы данных  
- `Sequence<Type>` — абстрактный класс для последовательностей  
- `ArraySequence<Type>` — реализация последовательности на динамическом массиве  
- `ListSequence<Type>` — реализация последовательности на двусвязном списке  
- `Mapper<Type>` — функция, применяемая к каждому элементу (аналог map)  
- `Condition<Type>` — функция-фильтр (аналог filter)  
- `Reducer<Type>` — функция для свёртки значений (аналог reduce)  

---

## Функции

### Sequence.hpp

#### Шаблонный абстрактный класс `Sequence<Type>`


#### Методы:

- `~Sequence()`  
    > Виртуальный деструктор

- `Create() const -> Sequence<Type>*`  
    > Создаёт пустую последовательность того же типа  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый объект `Sequence<Type>`

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент в заданную позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент  
    >   * **index** — позиция

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента

- `IsEmpty() const -> bool`  
    > Проверяет, пуста ли последовательность  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если элементов нет

- `GetFirst() const -> Type&`  
    > Возвращает первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `GetLast() const -> Type&`  
    > Возвращает последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Map(func: Mapper<Type>) const -> Sequence<Type>*`  
    > Возвращает новую последовательность, где к каждому элементу применена функция  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция отображения
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность

- `Where(filter: Condition<Type>) const -> Sequence<Type>*`  
    > Возвращает новую последовательность из элементов, удовлетворяющих фильтру  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — функция-фильтр
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность

- `Reduce(reduce: Reducer<Type>, base: Type) const -> Type`  
    > Последовательно сворачивает элементы с помощью аккумулятора  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **reduce** — функция аккумуляции  
    >   * **base** — начальное значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат аккумуляции

- `operator<<(ostream& os, Sequence<Type>* array)`  
    > Вывод последовательности в виде строки  
    >
    > _ФОРМАТ:_  
    >   * `[elem1, elem2, ...]`

- `operator==(sequence: const Sequence<Type>&) -> bool`  
    > Сравнивает две последовательности поэлементно

- `operator[](index: int) const -> Type&`  
    > Доступ к элементу по индексу


---

### DynamicArray.hpp

#### Шаблонный класс `DynamicArray<Type>`

> Реализация динамического массива с возможностью изменения размера, индексированием и перегрузкой операторов

```cpp
template<typename Type>
class DynamicArray {
private:
    Type* data;
    size_t size;
public:
    ...
};
```

---

##### Поля:

- `data` — указатель на блок памяти, содержащий элементы массива
- `size` — текущее количество элементов в массиве

---

#### Конструкторы и деструктор:

- `DynamicArray()`  
    > Конструктор по умолчанию  
    >
    > Создаёт массив из одного элемента, инициализированного значением по умолчанию

- `DynamicArray(size: size_t)`  
    > Конструктор пустого массива заданного размера  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **size** — количество элементов

- `DynamicArray(items: Type*, size: size_t)`  
    > Конструктор из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив элементов  
    >   * **size** — количество

- `DynamicArray(dynamicArray: const DynamicArray<Type>&)`  
    > Конструктор копирования

- `DynamicArray(head: Type, args...)`  
    > Шаблонный конструктор с произвольным количеством аргументов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — значения, из которых строится массив

- `~DynamicArray()`  
    > Деструктор. Освобождает память

---

#### Методы:

- `void Resize(newSize: size_t)`  
    > Изменяет размер массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **newSize** — новый размер массива

- `Type& Get(index: int) const`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент  
    >
    > _ИСКЛЮЧЕНИЯ:_  
    >   * `std::out_of_range`, если индекс некорректен

- `void Set(index: int, element: Type)`  
    > Заменяет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >   * **element** — новое значение

- `int Size() const noexcept`  
    > Возвращает текущий размер массива  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Количество элементов

---

#### Операторы:

- `operator==(sequence: const DynamicArray<Type>&) -> bool`  
    > Сравнивает два массива поэлементно

- `operator[](index: int) const -> Type&`  
    > Индексация массива  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `operator<<(os: ostream&, array: const DynamicArray<Type>&)`  
    > Форматированный вывод массива в виде `[x1, x2, ..., xn]`


---

### ArraySequence.hpp

#### Шаблонный класс `ArraySequence<Type>`

> Конкретная реализация абстрактного класса `Sequence<Type>`, основанная на `DynamicArray<Type>`

```cpp
template<typename Type>
class ArraySequence : public Sequence<Type> {
private:
    DynamicArray<Type>* items;
public:
    ...
};
```

---

##### Поля:

- `items` — указатель на внутренний динамический массив, в котором хранятся элементы последовательности (`DynamicArray<Type>*`)

---

#### Методы:

- `ArraySequence()`  
    > Конструктор по умолчанию  
    >
    > Создаёт пустую последовательность

- `ArraySequence(items: Type*, size: size_t)`  
    > Конструктор из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив значений  
    >   * **size** — количество элементов

- `ArraySequence(dynamicArray: const DynamicArray<Type>&)`  
    > Конструктор копирования из `DynamicArray`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **dynamicArray** — массив-источник

- `~ArraySequence()`  
    > Деструктор. Освобождает память

- `Create() const -> Sequence<Type>*`  
    > Возвращает новый пустой объект `ArraySequence<Type>`

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент на позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемый элемент  
    >   * **index** — позиция вставки

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция элемента

- `Set(index: int, value: Type)`  
    > Устанавливает значение по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >   * **value** — новое значение

---

### List.hpp

#### Шаблонный класс `LinkedList<Type>`

> Односвязный список с итераторами и базовыми операциями над элементами

---

#### Вспомогательная структура `Node<Type>`
```cpp
template<typename Type>
class Node {
public:
    Type value;
    Node<Type>* next;

    ...
};
```

##### Поля:
- `value` — значение узла
- `next` — указатель на следующий элемент

---

#### Класс `LinkedList<Type>`

```cpp
template<typename Type>
class LinkedList {
private:
    Node<Type>* head;
    Node<Type>* tail;
    size_t size;
public:
    ...
};
```

---

##### Поля:
- `head` — указатель на первый элемент списка (`Node<Type>*`)
- `tail` — указатель на последний элемент списка (`Node<Type>*`)
- `size` — количество элементов в списке (`size_t`)

---

#### Методы:

- `LinkedList()`  
    > Конструктор по умолчанию. Создаёт пустой список

- `LinkedList(items: Type*, size: size_t)`  
    > Создаёт список из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив значений  
    >   * **size** — количество элементов

- `LinkedList(list: const LinkedList<Type>&)`  
    > Конструктор копирования

- `LinkedList(head: Type, args...)`  
    > Шаблонный конструктор с аргументами  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head** — первый элемент  
    >   * **args...** — оставшиеся элементы

- `~LinkedList()`  
    > Деструктор. Удаляет все узлы списка

- `IsEmpty() const -> bool`  
    > Проверяет, пуст ли список  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если нет элементов

- `Size() const -> size_t`  
    > Возвращает количество элементов

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `GetFirst() const -> Type&`  
    > Первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `head->value`

- `GetLast() const -> Type&`  
    > Последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `tail->value`

- `Append(value: const Type&)`  
    > Добавляет элемент в конец

- `Prepend(value: const Type&)`  
    > Добавляет элемент в начало

- `Insert(index: int, value: const Type&)`  
    > Вставляет элемент по индексу

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `operator==(list: const LinkedList<Type>&) -> bool`  
    > Сравнение списков поэлементно

- `operator[](index: int) const -> Type&`  
    > Обращение к элементу через `[]`

- `operator<<(os: ostream&, list: const LinkedList&)`  
    > Печатает список в формате: `[x1, x2, ..., xn]`

- `Begin() -> ListIterator`  
    > Итератор на первый элемент

- `End() -> ListIterator`  
    > Итератор на `nullptr`

---

#### Вложенный класс `ListIterator`

```cpp
class ListIterator {
private:
    Node<Type>* current;
public:
    ...
};
```

##### Поля:
- `current` — указатель на текущий узел в процессе итерации

---

##### Методы:


- `operator++()`  
    > Переход к следующему элементу

- `operator*() -> Type&`  
    > Доступ к значению

- `operator==(...)`, `operator!=(...)`  
    > Сравнение итераторов


---

### ListSequence.hpp

#### Шаблонный класс `ListSequence<Type>`

> Конкретная реализация абстрактного класса `Sequence<Type>`, основанная на связном списке `LinkedList<Type>`

```cpp
template<typename Type>
class ListSequence : public Sequence<Type> {
private:
    LinkedList<Type>* items;
public:
    ...
};
```

---

#### Методы:

- `ListSequence()`  
    > Конструктор по умолчанию  
    >
    > Создаёт пустую последовательность на базе пустого списка

- `ListSequence(items: Type*, size: size_t)`  
    > Создаёт список из массива элементов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив  
    >   * **size** — количество элементов

- `ListSequence(listSequence: const ListSequence<Type>&)`  
    > Конструктор копирования  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **listSequence** — другая последовательность

- `ListSequence(head: Type, args...)`  
    > Инициализация через список аргументов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — значения, добавляемые в последовательность

- `~ListSequence()`  
    > Деструктор. Освобождает память

- `Create() const -> Sequence<Type>*`  
    > Возвращает новый пустой объект `ListSequence<Type>`

- `Get(index: int) const -> Type&`  
    > Получает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент  
    >   * **index** — позиция вставки

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `Begin() -> Iterator`  
    > Возвращает итератор на начало списка

- `End() -> Iterator`  
    > Возвращает итератор на конец списка

---

### Menu.hpp

#### Назначение

Модуль `Menu.hpp` реализует пользовательское текстовое меню для управления объектами типа `Sequence<float>`, позволяя пользователю выполнять базовые операции с последовательностями (добавление, вставка, вывод и т.д.).

---

#### Макросы

- `EMPTY`  
    > Проверка, существует ли объект `seq`.  
    > Если `nullptr` — выводит сообщение `"Sequence is empty"` и завершает текущую операцию.

- `DELETE`  
    > Удаляет объект `seq` и устанавливает его в `nullptr`.

- `PRINT`  
    > Печатает текущую последовательность `seq` на экран.

---

#### Функции

- `void talker()`  
    > Выводит список доступных действий пользователю:
    >
    > 1. Создать `ArraySequence`  
    > 2. Создать `ListSequence`  
    > 3. Печать  
    > 4. Первый элемент  
    > 5. Последний элемент  
    > 6. Получить по индексу  
    > 7. Размер  
    > 8. Добавить в конец  
    > 9. Добавить в начало  
    > 10. Вставить по индексу  
    > 0. Завершить программу

- `void menu()`  
    > Основной цикл пользовательского взаимодействия.  
    > Поддерживает все действия, описанные в `talker()`:
    >
    > _Локальные переменные:_  
    >   * `flag` — флаг завершения  
    >   * `choice` — пользовательский выбор  
    >   * `index` — индекс для операций  
    >   * `value` — значение типа `float`  
    >   * `seq` — текущая последовательность (`Sequence<float>*`)

    > _Основные действия:_  
    >   * Создание новых последовательностей (`ArraySequence`, `ListSequence`)  
    >   * Вывод содержимого  
    >   * Получение элементов (первый, последний, по индексу)  
    >   * Изменение последовательности (добавление, вставка)  
    >   * Очистка и завершение работы
